%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Protocol Buffer
scope: source.proto
file_extensions:
  - proto
  - protodevel
first_line_match: '^(syntax)\s*(=)\s*("proto\d")\s*(;)\s*$'
variables:
  ident: '\b([A-Za-z][A-Za-z0-9_]*)\b'

contexts:
  prototype:
    # Captured for practical reasons (keeps other patterns simpler)
    - match: '\s+'
    - include: comments

  comments:
    - match: //
      scope: punctuation.definition.comment.begin.proto
      push:
        - meta_scope: comment.line.proto
        - match: '$'
          pop: true
    - match: /\*
      scope: punctuation.definition.comment.proto
      push:
        - meta_scope: comment.block.proto
        - match: \*/
          scope: punctuation.definition.comment.proto
          pop: true

  any_POP:
    # Pop when seeing unexpected characters.
    - match: '(?=\S)'
      pop: true

  one_liner:
    - match: ;
      scope: punctuation.terminator.proto
      pop: true
    - match: $
      pop: true

  closingBraceUnexpected_POP:
    - match: '(?=\})' # Recover from a non complete assignment
      pop: true

  stringDouble:
    - match: '"'
      scope: punctuation.definition.string.begin.proto
      push:
        - meta_scope: string.quoted.double.proto
        - meta_include_prototype: false
        - match: '\\"'
          scope: constant.character.escape.proto
        - match: '"'
          scope: punctuation.definition.string.end.proto
          pop: true

  stringDoubleMultiline:
    - include: stringDouble
    - include: any_POP

  enum:
    - match: '\b(enum)\b\s*{{ident}}'
      captures:
        1: storage.modifier.enum.proto
        2: entity.name.enum.proto
      push:
        - meta_scope: meta.enum.proto
        - match: '\{'
          scope: punctuation.definition.block.enum.begin.proto
          set: enumBody
        - include: any_POP

  enumBody:
    - meta_scope: meta.enum.proto
    - match: '}'
      scope: punctuation.definition.block.enum.end.proto
      pop: true
    - include: inlineOption
    - include: fieldAttributes
    - match: '{{ident}}'
      scope: support.variable.proto
    - match: =
      scope: keyword.operator.assignment.proto
    - match: \d+
      scope: constant.numeric.proto
    - match: ';'
      scope: punctuation.terminator.proto

  oneof:
    - match: '\b(oneof)\b'
      scope: storage.modifier.oneof.proto
      push: [ oneofBody_START, field_name_POP]
  oneofBody_START:
    - match: '\{'
      scope: punctuation.definition.block.oneof.begin.proto
      set: oneofBody_AFTER_OPEN
  oneofBody_AFTER_OPEN:
    - meta_scope: meta.oneof.body.proto
    - match: '}'
      scope: punctuation.definition.block.oneof.end.proto
      pop: true
    - match: ''
      push: [ messageField_END, field_name_POP, messageType_POP ]

  extend_START:
    - match: '\b(extend)\b'
      scope: storage.modifier.extend.proto
      push: [ extendBody_START, messageType_POP]
  extendBody_START:
    - match: '\{'
      scope: punctuation.definition.block.extend.begin.proto
      set: extendBody_AFTER_OPEN
  extendBody_AFTER_OPEN:
    - meta_scope: meta.extend.body.proto
    - match: '}'
      scope: punctuation.definition.block.extend.end.proto
      pop: true
    - include: messageBody

  reserved_START:
    - match: '\b(reserved)\b'
      scope: storage.modifier.reserved.proto
      push:
        - match: \d+
          scope: constant.numeric.proto
        - match: ','
          scope: punctuation.separator.proto
        - match: to
          scope: keyword.other.to.proto
        - match: ';'
          scope: punctuation.terminator.proto
          pop: true


  # Service rules
  service:
    - match: '\b(service)\b\s*{{ident}}'
      captures:
        1: storage.modifier.service.proto
        2: entity.name.class.proto
      push:
        - meta_scope: meta.service.proto
        - match: '\{'
          scope: punctuation.definition.block.service.begin.proto
          set:
            - meta_scope: meta.service.proto
            - match: '}'
              scope: punctuation.definition.block.service.end.proto
              pop: true
            - include: inlineOption
            - include: rpc_START
        - include: any_POP

  # RPC Service rules
  rpc_START:
    - match: '\b(rpc)\b\s*{{ident}}'
      captures:
        1: storage.modifier.rpc.proto
        2: entity.name.function.rpc.proto
      push: [rpcBody_START, rpc_PARAM, rpc_RETURNS, rpc_PARAM]

  rpc_RETURNS:
    - match: returns
      scope: keyword.other.returns.proto
      pop: true

  rpc_PARAM:
    - match: \(
      scope: punctuation.definition.parameter.rpc.begin.proto
      set:
        - match: \)
          scope: punctuation.definition.parameter.rpc.end.proto
          pop: true
        - match: '\bstream\b'
          scope: storage.modifier.proto
        - include: messageType_POP

  rpcBody_START:
    - match: '\{'
      scope: punctuation.definition.block.rpc.begin.proto
      set: rpcBody_AFTER_OPEN
    - match: ;
      scope: punctuation.terminator.proto
      pop: true

  rpcBody_AFTER_OPEN:
    - meta_scope: meta.rpc.body.proto
    - match: '}'
      scope: punctuation.definition.block.rpc.end.proto
      pop: true
    - include: rpcBody

  rpcBody:
    - meta_scope: meta.rpc.body.proto
    - include: inlineOption

  # Message Rules
  message:
    - match: '\b(message)\b\s*{{ident}}'
      captures:
        1: storage.modifier.message.proto
        2: entity.name.class.proto
      push:
        - meta_scope: meta.class.proto
        - match: '\{'
          scope: punctuation.definition.block.message.begin.proto
          set: messageBody
        - include: any_POP

  messageBody:
    - meta_scope: meta.class.proto
    - match: '}'
      scope: punctuation.definition.block.message.end.proto
      pop: true
    - include: inlineOption
    - include: message
    - include: extend_START
    - include: oneof
    - include: enum
    - include: reserved_START
    - include: messageBodyField

  messageType_POP:
    # see documentation for the list of base types:
    # https://developers.google.com/protocol-buffers/docs/proto#scalar
    - match: '(double|float|bool|string|bytes)'
      scope: support.type.proto
      pop: true
    - match: '(u|s)?int(32|64)'
      scope: support.type.proto
      pop: true
    - match: 's?fixed(32|64)'
      scope: support.type.proto
      pop: true
    - match: '{{ident}}(\.)'
      captures:
        1: variable.namespace.proto
        2: punctuation.accessor.proto
    - match: '{{ident}}'
      scope: variable.type.proto
      pop: true
    - include: any_POP

  field_name_POP:
    - match: '{{ident}}'
      scope: variable.other.field.proto
      pop: true
    - include: closingBraceUnexpected_POP

  messageField_END:
    - include: fieldAttributes
    - match: ';'
      scope: punctuation.terminator.proto
      pop: true
    - match: =
      scope: keyword.operator.assignment.proto
    - match: \d+
      scope: constant.numeric.proto
    - include: closingBraceUnexpected_POP

  fieldAttributes:
    - match: '\['
      scope: punctuation.definition.attributes.begin.proto
      push:
        - meta_scope: meta.field.attributes.proto
        - include: fieldAttribute_BODY
        - match: \,
          scope: punctuation.separator.option.proto
        - match: '\]'
          scope: punctuation.definition.attributes.end.proto
          pop: true
  map_type:
    - match: ','
      scope: punctuation.separator.map.proto
    - match: '>'
      scope: punctuation.definition.map.end.proto
      pop: true
    - match: '(?={{ident}})'
      push: messageType_POP

  messageBodyField:
    - match: '\b(optional|required|repeated)\b'
      captures:
        1: storage.modifier.proto
      push: [ messageField_END, field_name_POP, messageType_POP ]
    - match: '\b(map)\b\s*\b(<)'
      captures:
        1: storage.modifier.proto
        2: punctuation.definition.map.begin.proto
      push: [ messageField_END, field_name_POP, map_type ]

  inlineOption:
    - match: '\b(option)\b'
      scope: keyword.other.option.proto
      push:
        - include: option_BODY
        - match: ';'
          scope: punctuation.terminator.option.proto
          pop: true

  fieldAttribute_BODY:
    - match: \b(default|deprecated|packed)\b
      scope: constant.language.default.proto
    - match: '{{ident}}'
      scope: variable.other.option.proto
    - include: optionName
    - include: optionAssignment

  option_BODY:
    - match: '{{ident}}'
      scope: variable.other.option.proto
    - include: optionName
    - include: optionAssignment

  optionName:
    - match: \(
      scope: punctuation.definition.name.option.begin.proto
      push:
        - match: \)
          scope: punctuation.definition.name.option.end.proto
          set:
            - match: (\.)([\w\d]*)
              captures:
                1: punctuation.accessor.proto
                2: storage.type.option.proto
            - include: any_POP
        - match: '[^\)]+'
          scope: storage.type.option.proto

  optionAssignment:
    - match: =
      scope: keyword.operator.assignment.proto
      push: optionAfterAssignment_POP

  optionEnd_pop:
    - match: '}'
      scope: punctuation.definition.block.option.end.proto
      pop: true

  optionAfterAssignment_POP:
    - meta_scope: meta.option.assignment.after.proto
    - match: '{'
      scope: punctuation.definition.block.option.begin.proto
      embed: scope:source.prototext
      embed_scope: source.prototext.embedded.proto
      escape: '}'
    - include: constant_POP

  option_ASSIGN_BLOCK:
    - meta_scope: meta.object-literal.proto
    - match: '}'
      scope: punctuation.definition.block.option.end.proto
      pop: true
    - match: '(\w+)(:)'
      captures:
        1: meta.object-literal.key.proto
        2: punctuation.separator.key-value.proto
      push: [objectLiteralValue_META, constant_POP]

  # This is a hack to get the meta scope to wrap
  objectLiteralValue_META:
    - meta_scope: meta.object-literal.value.proto
    - match: ''
      pop: true

  constant_POP:
    - match: \d+
      scope: constant.numeric.proto
      pop: true
    - match: \btrue\b|\bfalse\b
      scope: constant.language.proto
      pop: true
    - match: '{{ident}}'
      scope: constant.other.proto
      pop: true
    - include: stringDoubleMultiline
    # No constants matched
    - include: any_POP

  main:
    - match: \b(package)\b
      scope: keyword.other.namespace.proto
      push:
        - match: '{{ident}}(\.)'
          captures:
            1: variable.namespace.proto
            2: punctuation.separator.namespace.proto
        - match: '{{ident}}'
          scope: entity.name.namespace.proto
        - include: one_liner
    # This is proto1 syntax which is deprecated, only providing minimal support.
    - match: '\b(parsed)?\s*((class))\s+{{ident}}\s+{'
      scope: meta.parsed.message.proto
      captures:
        1: storage.type.parsed.proto
        3: storage.type.message.proto
        4: invalid.deprecated.class.proto
        5: entity.name.function.proto
    # Groups are deprecated, only providing minimal support.
    - match: '(?x)\b(group)\s+(\w+)\s+=\s+(\d+)\s+{'
      scope: meta.group.proto
      captures:
        1: storage.type.proto invalid.deprecated.group.proto
        2: support.variable.proto
        3: constant.numeric.proto
      push:
        - match: '\}'
          pop: true
        - include: field
    - match: '^\s*(syntax)\s*(=)'
      captures:
        1: keyword.other.syntax.proto
        2: keyword.operator.assignment.proto
      push:
        - include: stringDouble
        - include: one_liner
    - match: '\b(import)\b'
      captures:
        1: keyword.other.import.proto
      push:
        - include: stringDouble
        - include: one_liner
    - include: inlineOption
    - include: message
    - include: service
    - include: extend_START
    - include: enum
