%YAML 1.2
---
name: Scala
file_extensions: [.scala, .sbt]
scope: 'source.scala'


variables:

  # _ : = => <- <: <% >: # @
  reserved_op: '(_|:|=>|=|<-|<:|<%|>:|#)\b'

  # see this SO question for more details:
  # http://stackoverflow.com/questions/7656937/valid-identifier-characters-in-scala
  operator: '[!#%&\*\+\-/:<=>?\\^|~©®][!#%&\*\+\-/:<=>?@\\^|~©®]*'
  simple_name: '[A-Za-z_\p{L}][A-Za-z\p{L}_0-9]*'
  name_with_op: '({{operator}}|{{simple_name}}_{{operator}})'
  name: '({{operator}}|{{simple_name}}_{{operator}}|{{simple_name}})'
  full_name: '({{operator}}\s|{{simple_name}}_{{operator}}\s|{{simple_name}}\s?)'

  tagname: '@{{name}}'

  xml_open_tag: '<[A-Za-z]*>'
  xml_close_tag: "</[A-Za-z]*>"

  # integers
  hex_numeral: '0[xX][0-9a-fA-F]+'
  decimal_numeral: '[1-9][0-9]*[lL]'
  integers: '({{hex_numeral}}|{{decimal_numeral}}|0)'

  # floating point numbers
  exponent: '[eE][+\-]?[0-9]+'
  floating_point: '[0-9]+(?:\.[0-9]+)?(?:{{exponent}})?[fFdD]?'
  number: '({{hex_numeral}}|{{decimal_numeral}}|{{floating_point}}|0)'
  # characters
  escaped_char: \\([btnfr"'\\]|u[0-9a-fA-F]{4})
  char: '(?:{{escaped_char}}|.)'
  string: '(f|s|raw)?\"[^\"]*\"'
  literal: '({{number}}|{{char}}|{{string}})'
  variable: '({{name}}\.)*{{name}}'
  value: '({{literal}}|{{variable}})'

contexts:
  prototype:
    - include: 'comments'

  # comments
  comments:
    - match: '//.*$'
      scope: comment.line.double-slash.scala
    - match: '/\*[^*]'
      push:
        - meta_scope: comment.block.scala
        - match: '\*/'
          pop: true

  # punctuation:
  #   - match: (\.|\,)
  #     scope: keyword.operator.scala

  main:
    #TODO: forSome

    # scaladoc is triggered only on new line
    - match: '^\s*/\*\*'
      push: scaladoc

    - match: '\}'
      scope: invalid.illegal.unexpected.closing-bracket

    - match: '\{'
      scope: punctuation.definition.block.begin.scala
      push:
        - match: '\}'
          scope: punctuation.definition.block.end.scala
          pop: true
        - include: main

    # skips opening
    - match: ^\s*

    # annotations
    - match: '{{tagname}}'
      scope: entity.name.tag

    # embedded xml see:
    # http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#xml-mode
    - match: '[\s({]{{xml_open_tag}}'
      scope: entity.name.tag
      push: xml
    - match: '{{xml_close_tag}}'
      scope: invalid.illegal.xml-close-tag


    # packages/object declaration
    - match: '\b(package)\s(({{simple_name}}\.)*{{simple_name}})'
      captures:
        1: keyword.other.scoping.scala
        2: entity.name.package.scala

    # class declaration
    - match: '\b(case\s*class)\s{{name}}'
      captures:
        1: storage.type.class.case-class.scala
        2: entity.name.class.scala
      push: class_signature

    - match: '\b(class)\s{{name}}'
      captures:
        1: storage.type.class.class.scala
        2: entity.name.class.scala
      push: class_signature

    - match: '\b(case\s)?(object)\s{{name}}'
      captures:
        1: storage.modifier.other.case.scala
        2: storage.type.class.object.scala
        3: entity.name.class.scala
      push: class_signature

    - match: '(trait)\s{{name}}'
      captures:
        1: storage.type.class.trait.scala
        2: entity.name.class.scala
      push: class_signature

    # function/method definition
    - match: '(def)\s({{name}})'
      captures:
         1: storage.type.function.scala
         2: entity.name.function.scala
      push: signature

    # val/var declaration
    - match: '\b(val)\s+'
      scope: storage.type.variable.val.scala
      push: pattern
    - match: '\b(var)\s+'
      scope: storage.type.variable.var.scala
      push: pattern

    # type declaration
    - match: '\b(type)\s+{{name}}\s*(=|<:|<%)'
      captures:
        1: storage.type.variable.type.scala
        2: entity.name.type.scala
        3: keyword.operator.assignment.scala
      push: type

    # language keywords
    - match: \b(if)\s+(\()
      captures:
        1: keyword.control.flow.if.scala
        2: punctuation.definition.expression.conditional.begin.scala
      push:
        - meta_scope: meta.if.condition
        - match: '\)'
          scope: punctuation.definition.expression.conditional.end.scala
          pop: true
        - include: main

    - match: \b(else|for|while|do|match|case|return|yield)\b
      scope: keyword.control.flow.scala
    - match: \b(try|catch|finally)\b
      scope: keyword.control.exception.scala
    - match: \b(throw)\b
      scope: keyword.control.jump.scala
    - match: \b(this|super)\b
      scope: variable.language.scala
    - match: \b(new)\s{{name}}
      captures:
        1: keyword.declaration.new.scala
        2: variable.other.type.scala
    - match: \b(sealed|abstract|final|lazy|override)\b
      scope: storage.modifier.other.scala

    # private/protected with modifier
    - match: '\b(private|protected)\s*\[(this)\]'
      captures:
        1: storage.modifier.other.scala
        2: variable.language.scala
    - match: '\b(private|protected)\s*(\[){{name}}(\])'
      captures:
        1: storage.modifier.other.scala
        2: punctuation.declaration.parameters.begin.scala
        3: punctuation.declaration.parameters.end.scala
    - match: \b(private|protected)\b
      scope: storage.modifier.access.scala

    # language constants
    - match: \b(true|false|None|Nil|null)\b
      scope: constant.language.scala
    # characters
    - match: "'\\\\'"
      scope: invalid.illegal.lone-escape.scala
    - match: "'{{escaped_char}}'"
      scope: constant.character.escape.scala
    - match: "'.'"
      scope: constant.character.scala
    - match: "'[^']+'"
      scope: invalid.illegal.not_a_char.scala

    # numbers
    - match: '{{number}}'
      scope: constant.numeric.scala

    # import
    - match: \bimport\b
      scope: keyword.other.import
      push: import

    # string detection
    - match: '"""'
      scope: punctuation.definition.string.quoted.triple.begin.scala
      push: triple_string
    - match: 's"'
      scope: punctuation.definition.string.interpolated.begin.scala
      push: s_string
    - match: 'f"'
      scope: punctuation.definition.string.interpolated.begin.scala
      push: f_string
    - match: 'raw"'
      scope: punctuation.definition.string.quoted.raw.begin.scala
      push: raw_string
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.scala
      push: string

    # function calls
    - match: \b(Array|List|Map|Some)(\()
      captures:
        1: support.class.builtin.scala
        2: punctuation.definition.parameters.begin.scala
      push: function_args
    - match: \b(assert|assume|classOf|identity|implicitly|locally|manifest|optManifest|print|printf|println|require)(\()
      captures:
        1: support.function.builtin.scala
        2: punctuation.definition.parameters.begin.scala
      push: function_args
    - match: '([A-Z]{{name}})(\()'
      captures:
        1: variable.type.constructor
        3: punctuation.definition.parameters.begin.scala
      push: function_args
    - match: '{{name}}(\()'
      captures:
        1: variable.function
        2: punctuation.definition.parameters.begin.scala
      push: function_args

    # tuples
    - match: '\)'
      scope: invalid.illegal.unexpected.closing-par
    - match: '(\()'
      captures:
        1: punctuation.definition.array.begin.scala
      push:
        - meta_scope: meta.tuple
        - match: ','
          scope: punctuation.separator.array.scala
        - match: '\)'
          scope: punctuation.definition.array.end.scala
          pop: true
        - include: main

    # builtin and operators
    - match: '(=)\s'
      captures:
        1: keyword.operator.assignment
    - match: '{{reserved_op}}'
      scope: support.function.builtin.scala
    - match: ';'
      scope: punctuation.terminator.statement.scala
    - match: ','
      scope: invalid.illegal.unexpected.coma
    - match: '\.'
      scope: keyword.operator.accessor.scala
    - match: \b(Array|List|Map|Some)\b
      scope: support.class.builtin.scala
    - match: \b(assert|assume|classOf|identity|implicitly|locally|manifest|optManifest|print|printf|println|require)\b
      scope: support.function.builtin.scala
    - match: '{{operator}}'
      scope: keyword.operator.scala

    # type parameters
    - include: type_bracket

    # try to match class name
    - match: '[A-Z]{{name}}?'
      scope: variable.other.type
    - match: '{{name}}'
      # scope: variable.other
    # - include: punctuation

  # type
  type:
    # tuple of type
    - match: '\('
      scope: punctuation.definition.parameters.begin.scala
      push:
        - match: '\)'
          scope: punctuation.definition.parameters.end.scala
          pop: true
        - match: $
          pop: false
        - match: ','
          scope: punctuation.separator.array
    - match: '\b(with)\b'
      scope: keyword.declaration.scala
    # type parameter
    - include: type_bracket
    - match: '(<:|<%)'
      scope: keyword.operator.type-bound.scala
    - match: '=>'
      scope: support.function.func-type.scala
    - match: \)
      scope: invalid.illegal.unexpected.closing-par
    - match: '{{name}}'
      scope: variable.other.type
    - match: '(?=,|=)'
      pop: true
    - match: '$'
      pop: true
    # - include: punctuation

  type_bracket:
    - match: '\['
      scope: punctuation.definition.parameters.begin.scala
      push:
        - meta_scope: meta.parameters.type
        - match: '\]'
          scope: punctuation.definition.parameters.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.type-tuple.scala
        - match: $
          pop: false
        - include: type
    - match: \]
      scope: invalid.illegal.stray-bracket-end

  import:
    - meta_scope: meta.import.scala
    - match: _
      scope: constant.language.scala
      pop: true
    - match: '{{name}}'
      scope: variable.package.scala
    - match: \.
      scope: punctuation.separator.dot
    - match: $
      pop: true
    - match: \{
      scope: punctuation.definition.module-binding.begin.scala
      push:
        - match: \}
          scope: punctuation.definition.module-binding.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.module-binding
        - match: '{{name}}\s*(=>)\s*(_)'
          captures:
            1: meta.import.suppressed.scala
            2: support.function.mapping.scala
            3: constant.language.underscore.scala
        - match: '(=>)\s*({{name}})'
          captures:
            1: support.function.mapping.scala
            2: entity.name.class
        - match: '([A-Z]{{name}}?)\s*(?=[,}])'
          captures:
            1: entity.name.class.imported

        # - include: import
    # - include: punctuation

  string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.scala
    - include: escaped
    - match: '"'
      scope: punctuation.definition.string.quoted.double.end.scala
      pop: true
    - match: '[^"]*$'
      scope: invalid.string.newline
      pop: true


  raw_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.scala
    - match: '"'
      scope: punctuation.definition.string.quoted.raw.end.scala
      pop: true
    - match: "[^\"]*$"
      scope: invalid.string.newline
      pop: true
    - match: \\u[0-9a-fA-F]{4}
      scope: constant.character.escape.scala

  triple_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.triple.scala
    - include: escaped
    - match: '"""'
      scope: punctuation.definition.string.quoted.triple.end.scala
      pop: true

  s_string:
    - meta_include_prototype: false
    - meta_scope: string.interpolated.scala
    - match: '(\$)\{'
      scope: punctuation.definition.string.interpolated.element.begin.scala
      push:
        - meta_scope: source.scala
        - match: '\}'
          scope: punctuation.definition.string.interpolated.element.end.scala
          pop: true
        - include: 'main'
    - match: '(\$){{name}}'
      captures:
        1: punctuation.definition.string.interpolated.element.scala
        2: source.scala
    - match: '"'
      scope: punctuation.definition.string.interpolated.end.scala
      pop: true
    - include: escaped

  # f_string, see:
  # http://docs.oracle.com/javase/6/docs/api/java/util/Formatter.html#detail
  # /!\ this implementation may allow incorrect combinaisons
  f_string:
    - meta_include_prototype: false
    - meta_scope: string.interpolated.scala
    - include: s_string
    # constant formatting
    - match: '%[%n]'
      scope: punctuation.definition.string.interpolated.element.scala
    # general formatting
    - match: '%\-?#?[bBhHsS]'
      scope: punctuation.definition.string.interpolated.element.scala
    # character formatting
    - match: '%\-?[cC]'
      scope: punctuation.definition.string.interpolated.element.scala
    # date-time formatting
    - match: '%\-?[tT][HIklMSLNpzZsQBbhAaCYyjmdeRTrDFc]?'
      scope: punctuation.definition.string.interpolated.element.scala
    # floating point formatting
    - match: '%[\+\-# 0\(,]*[\.0-9]*[feEgGaA]'
      scope: punctuation.definition.string.interpolated.element.scala
    # integer formatting
    - match: '%[\+\-# 0\(,]*[doxX]'
      scope: punctuation.definition.string.interpolated.element.scala

  escaped:
    - match: '{{escaped_char}}'
      scope: constant.character.escape.scala
    - match: \\[0-7]{1,3}
      scope: constant.character.escape.scala
    - match: \\
      scope: invalid.illegal.lone-escape.scala

  # method signature
  signature:
    - meta_scope: signature.scala
    - match: '\('
      push: params
      scope: punctuation.definition.parameters.begin.scala
    - match: '\['
      scope: punctuation.definition.parameters.begin.scala
      push: type_params
    - include: function_return_type

  type_params:
    # - meta_scope: 'type_params.scala'
    - match: '\]'
      scope: punctuation.definition.parameters.end.scala
      pop: true
    - match: '[$,]'
      pop: false
    - include: type

  params:
    # - meta_scope: params.scala
    - match: '\b(implicit)\b'
      scope: storage.modifier.other.implicit.scala
    - match: '{{name}}'
      captures:
        1: variable.parameter
      set:
        - match: '\s*(:)\s*'
          scope: punctuation.definition.type.scala
          set:
          - match: '\)'
            scope: punctuation.definition.parameters.end.scala
            pop: true
          - match: '=\s'
            scope: punctuation.separator.key-value.scala
            set:
              - match: '\)'
                scope: punctuation.definition.parameters.end.scala
                pop: true
              - match: ','
                set: params
              - include: main
          - match: ','
            scope: punctuation.separator.parameters.scala
            set: params
          - match: '$'
            pop: false
          - include: type
        - match: (.*)
          scope: invalid.illegal.expected_col
    - match: '\)'
      scope: punctuation.definition.parameters.end.scala
      pop: true
    - match: '($|,)'
      pop: false

  function_return_type:
    - meta_content_scope: meta.def.return-type.scala
    - match: ':'
      scope: punctuation.definition.type.scala
      set:
        - meta_scope: function_return_type.scala
        - match: $
          pop: false
        - match: '=\s*$?'
          scope: punctuation.definition.function.declaration.scala
          set: function_code
        - match: '(?=\{)'
          set: function_code
        - include: 'type'
    - match: =\s
      scope: punctuation.definition.function.declaration.scala
      set: function_code
    - match: '(?=\{)'
      set: function_code
    - match: '(?=\w)'
      pop: true


  function_code:
    - meta_scope: meta.def.scala
    - match: $
    - match: '^(\s*)(?=[^{])'
      captures:
        1: string.unquoted.block-indent
      set:
        - meta_scope: meta.def.scala
        - include: main
        - match: $
          pop: true
    - match: '(?=[^{])'
      captures:
        1: string.unquoted.block-indent
      set:
        - meta_scope: meta.def.scala
        - include: main
        - match: $
          pop: true
    - match: \s*
    - match: '\{'
      push:
        - match: '\}'
          pop: true
        - include: main

  # class signature
  class_signature:
    - meta_scope: meta.class.scala
    - match: '\('
      scope: punctuation.definition.parameters.begin.scala
      push: class_params
    - match: '\['
      scope: punctuation.definition.parameters.begin.scala
      push: type_params
    - match: '\s*\b(extends|with)\s{{name}}'
      captures:
        1: keyword.declaration.scala
        2: entity.other.inherited-class.scala
      push: extends
    - match: '\{'
      scope: punctuation.definition.class.begin.scala
      push:
        - match: '\}'
          scope: punctuation.definition.class.end.scala
          pop: true
        - include: main
    - match: \s*(?=\w)
      pop: true
    # - include: 'function_return_type'

  class_params:
    - meta_content_scope: meta.constructor.scala
    - match: '\b(implicit|val|protected|private)\b'
      scope: storage.modifier.other
    - match: '{{name}}\s*(:)\s*'
      captures:
        1: variable.parameter
        2: punctuation.definition.type.scala
      push:
        - match: (?=\)|,)
          pop: true
        - match: '=\s'
          scope: keyword.eq.scala
          set:
            - match: (?=\)|,)
              pop: true
            - include: main
        - match: '$'
          pop: false
        - include: type
    - match: '\)'
      scope: punctuation.definition.parameters.end.scala
      pop: true
    - match: '($|,)'
      pop: false

  extends:
    # - meta_scope: meta.extends.scala
    - match: '\s*\b(with)\s{{name}}'
      captures:
        1: keyword.declaration.scala
        2: entity.other.inherited-class.scala
    - match: '\('
      scope: punctuation.definition.parameters.begin.scala
      push:
        - meta_content_scope: source.scala
        - match: '\)'
          scope: punctuation.definition.parameters.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.argument.scala
        - include: main
    - match: '(?=\{)'
      pop: true
    - match: '$'
    - include: type

  function_args:
    - meta_content_scope: meta.function_args
    - match: ','
      scope: punctuation.separator.argument.scala
    - match: \)
      scope: punctuation.definition.parameters.end.scala
      pop: true
    - include: main

  pattern:
    - match: '\s*{{name}}?\s*(\()'
      captures:
        1: variable.type.constructor.unapply
        2: punctuation.definition.comprehension.array.begin.scala
      set: [pattern_ended, pattern_inside_unapply]
    - match: '(?=\S)'
      set: [pattern_ended, pattern_typed_name]

  pattern_typed_name:
    - match: '{{name}}\s*(:)\s'
      captures:
        1: entity.name.val.scala
        2: punctuation.definition.type.scala
      set:
        - match: '(?=\)|,|=)'
          pop: true
        - include: type
    - match: '{{name}}\s*(?==\s|\)|,)'
      captures:
        1: entity.name.val.scala
      pop: true
    - match: '{{name}}\s+{{name}}\s+'
      captures:
        1: entity.name.val.scala
        2: keyword.operator.infix-pattern
    - match: '\S+'
      scope: invalid.illegal.expected.pattern

  pattern_ended:
    - match: =>
      scope: keyword.operator.matching
      pop: true
    - match: =
      scope: keyword.operator.assignment
      pop: true
    - match: \s+
    - match: '{{name}}\s+(\()'
      captures:
        1: keyword.operator.infix-pattern
        2: punctuation.definition.comprehension.array.begin.scala
      push: pattern_inside_unapply
    - match: '{{name}}\s+'
      scope: keyword.operator.infix-pattern
      push: pattern_typed_name
    - match: (\S*)
      scope: invalid.illegal.expected.assignment
      pop: true

  pattern_inside_unapply:
    # - meta_scope: inside_unnaply
    - match: '(?==)'
    - match: '=\s'
      scope: invalid.illegal.unexpected-eq
    - match: ','
      scope: punctuation.separator.array-element
    - match: '\)'
      scope: punctuation.definition.comprehension.array.end.scala
      pop: true
    - match: '{{name}}?\s*(\()'
      captures:
        1: variable.other.type.unapply
        2: punctuation.definition.comprehension.array.begin.scala
      push: pattern_inside_unapply
    - match: '(?=\S)'
      push: pattern_typed_name

  xml:
    - meta_scope: text.xml
    - match: '({{xml_open_tag}})([^{]*)({{xml_close_tag}})'
      captures:
        1: entity.name.tag
        2: string.unquoted.xml
        3: entity.name.tag
    - match: '\{'
      captures:
        1: entity.name.tag
      push:
        - meta_scope: source.scala
        - match: '\}'
          pop: true
        - include: main
    - match: '{{xml_open_tag}}'
      scope: entity.name.tag
      push: xml
    - match: '{{xml_close_tag}}'
      scope: entity.name.tag
      pop: true

  scaladoc:
    - meta_include_prototype: false
    - meta_scope: comment.block.documentation.scala
    - match: '@(author|version|since)\b'
      scope: keyword.documentation.inventory.scala
    - match: '@(note|example|usecase)\b'
      scope: keyword.documentation.usage.scala
    - match: '@(todo)\b'
      scope: keyword.documentation.other.scala comment.todo.scala
    - match: '@(return|constructor)\b'
      scope: keyword.documentation.parameter.scala
    - match: '(@param)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: variable.parameter
    - match: '(@tparam)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: variable.other.type.scala
    - match: '(@throws)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: entity.name.type.scala
    - match: '(@see)\s+{{name}}'
      captures:
        1: keyword.documentation.link.scala
        2: entity.name.package.scala
    - match: '(\$){{name}}'
      captures:
        1: punctuation.definition.string.interpolated.element.scala
        2: entity.name.macro.scala
    - match: '(@define)\s+{{name}}\s'
      captures:
        1: keyword.documentation.other.scala
        2: entity.name.macro.scala
    - match: '@(inheritdoc)\b'
      scope: keyword.documentation.other.scala

    - include: scaladoc-markup

  scaladoc-markup:
    - match: '\s*\*/'
      pop: true
    - match: '^\s*\*'
      scope: comment.block.documentation.scala
    - match: '^(\s*.).*$'
      captures:
        1: invalid.illegal.missing-asterisk
    - match: "'''"
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.bold
        - match: "'''"
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: "''"
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.italic
        - match: "''"
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '__'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.underline
        - match: '__'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '\^'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.superscipt
        - match: '\^'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: ',,'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.subscipt
        - match: ',,'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '`'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.monospace
        - match: '`'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '\{\{\{'
      scope: constant.character.escaped.scaladoc
      set:
        - match: '\}\}\}'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
        - match: .
          scope : markup.code



