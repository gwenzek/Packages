%YAML 1.2
---
name: Scala
file_extensions: [.scala, .sbt]
scope: source.scala


variables:

  # _ : = => <- <: <% >: # @
  reserved_op: '(_|:|=>|=|<-|<:|<%|>:|#)\b'

  # see this SO question for more details:
  # http://stackoverflow.com/questions/7656937/valid-identifier-characters-in-scala
  operator: '[!#%&\*\+\-/:<=>?\\^|~©®][!#%&\*\+\-/:<=>?@\\^|~©®]*'
  simple_name: '[A-Za-z_\p{L}][A-Za-z\p{L}_0-9]*'
  name_with_op: '({{operator}}|{{simple_name}}_{{operator}})'
  name: '({{operator}}|{{simple_name}}_{{operator}}|{{simple_name}})'
  full_name: '({{operator}}\s|{{simple_name}}_{{operator}}\s|{{simple_name}}\s?)'

  tagname: '@{{name}}'

  xml_open_tag: '<[A-Za-z]*>'
  xml_close_tag: "</[A-Za-z]*>"

  # integers
  hex_numeral: '0[xX][0-9a-fA-F]+'
  decimal_numeral: '[1-9][0-9]*[lL]'
  integers: '({{hex_numeral}}|{{decimal_numeral}}|0)'

  # floating point numbers
  exponent: '[eE][+\-]?[0-9]+'
  floating_point: '[0-9]+(?:\.[0-9]+)?(?:{{exponent}})?[fFdD]?'
  number: '({{hex_numeral}}|{{decimal_numeral}}|{{floating_point}}|0)'
  # characters
  escaped_char: \\([btnfr"'\\]|u[0-9a-fA-F]{4})
  char: '(?:{{escaped_char}}|.)'
  string: '(f|s|raw)?\"[^\"]*\"'
  literal: '({{number}}|{{char}}|{{string}})'
  variable: '({{name}}\.)*{{name}}'
  value: '({{literal}}|{{variable}})'

contexts:
  prototype:
    - include: 'comments'

  # comments
  comments:
    - match: '//'
      push:
        - meta_scope: comment.line.double-slash.scala
        - match: $
          pop: true
        - include: comments_in
    - match: '/\*[^*]'
      push:
        - meta_scope: comment.block.scala
        - match: '\*/'
          pop: true
        - include: comments_in

  comments_in:
    - match: (?i:todo|hack)
      scope: comment.line.todo

  # punctuation:
  #   - match: (\.|\,)
  #     scope: keyword.operator.scala

  scaladoc_open:
    - match: '^\s*/\*\*'
      push: scaladoc

  main:
    #TODO: forSome

    # scaladoc is triggered only on new line
    - include: scaladoc_open

    - match: '\}'
      scope: invalid.illegal.unexpected.closing-bracket

    - match: '\{'
      scope: punctuation.definition.block.begin.scala
      push:
        - match: '\}'
          scope: punctuation.definition.block.end.scala
          pop: true
        - include: main

    # skips opening
    - match: ^\s*

    # annotations
    - match: '{{tagname}}'
      scope: entity.name.tag

    # embedded xml see:
    # http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#xml-mode
    - match: '[\s({]{{xml_open_tag}}'
      scope: entity.name.tag
      push: xml
    - match: '{{xml_close_tag}}'
      scope: invalid.illegal.xml-close-tag

    # class declaration
    - match: '\b(case\s*class)\s+{{name}}'
      captures:
        0: meta.class.identifier.scala
        1: storage.type.class.case-class.scala
        2: entity.name.class.scala
      push: class_signature

    - match: '\b(class)\s+{{name}}'
      captures:
        0: meta.class.identifier.scala
        1: storage.type.class.class.scala
        2: entity.name.class.scala
      push: class_signature

    - match: '\b((case)\s+|(package)\s+)?(object)\s+{{name}}'
      captures:
        0: meta.class.identifier.scala
        2: storage.modifier.other.case.scala
        3: storage.modifier.other.package.scala
        4: storage.type.class.object.scala
        5: entity.name.class.scala
      push: class_signature

    - match: '(trait)\s+{{name}}'
      captures:
        0: meta.class.identifier.scala
        1: storage.type.class.trait.scala
        2: entity.name.class.scala
      push: class_signature

    # package declaration
    - match: '\b(package)\s+(({{simple_name}}\.)*{{simple_name}})'
      captures:
        0: meta.package.identifier.scala
        1: storage.type.module
        2: entity.name.module.scala
      push:
        - meta_scope: meta.package.scala
        - include: main

    # function/method definition
    - match: '((def)\s+{{name}})'
      captures:
        1: meta.method.identifier.scala
        2: storage.type.function.scala
        3: entity.name.function.scala
      push: [signature_end, signature]

    # val/var declaration
    - match: '\b(val)\s+'
      scope: storage.type.variable.val.scala
      push: pattern
    - match: '\b(var)\s+'
      scope: storage.type.variable.var.scala
      push: pattern

    # type declaration
    - match: '\b(type)\s+{{name}}\s*(=|<:|<%)'
      captures:
        1: storage.type.variable.type.scala
        2: entity.name.class.scala
        3: keyword.operator.assignment.scala
      push: type
    - match: '\b(type)\s+{{name}}'
      captures:
        1: storage.type.variable.type.scala
        2: entity.name.class.scala
      push:
        - match: '(=|<:|<%)'
          scope: keyword.operator.assignment.scala
          set: type
        - include: type_bracket
        - match: $
          pop: true
        - match: (?=})
          pop: true

    # pattern matching
    - match: '\b{{name}}\s+(match)\b'
      captures:
        1: variable.other.scala
        2: keyword.control.switch.scala
      push:
        - match: \s*\{
          scope: punctuation.definition.block.switch.begin
          set:
            - match: \}
              scope: punctuation.definition.block.switch.end
              pop: true
            - match: \b(case)\b
              scope: keyword.control.switch.case.scala
              push: pattern
            - include: main
        - match: (\s*)\S
          scope: invalid.illegal.expected_block

    # language keywords
    - match: \b(if)\s*
      captures:
        1: keyword.control.conditional.if.scala
      push: [else_block, if_block, if_condition]

    - match: \b(for|while|do|match|case|return|yield)\b
      scope: keyword.control.flow.scala
    - match: \b(try)\b
      scope: keyword.control.trycatch.try.scala
      push: [finally_block, catch_block, try_block]

    - match: \b(throw)\b
      scope: keyword.control.jump.scala
    - match: \b(this|super)\b
      scope: variable.language.scala

    - match: \b(else|catch|finally)\b
      scope: keyword.control.scala invalid.illegal.unexpected.keyword

    # private/protected with modifier
    - match: '\b(private|protected)\s*\[(this)\]'
      captures:
        1: storage.modifier.access.scala
        2: variable.language.scala
    - match: '\b(private|protected)\s*(\[)([A-Z]{{name}})(\])'
      captures:
        1: storage.modifier.access.scala
        2: punctuation.definition.arguments.begin.scala
        3: entity.name.class.scala
        5: punctuation.definition.arguments.end.scala
    - match: '\b(private|protected)\s*(\[){{name}}(\])'
      captures:
        1: storage.modifier.access.scala
        2: punctuation.definition.arguments.begin.scala
        3: entity.name.module.scala
        4: punctuation.definition.arguments.end.scala
    - match: \b(private|protected)\b
      scope: storage.modifier.access.scala
    - match: \b(implicit)\b
      scope: storage.modifier.access.implicit.scala
    - match: \b(sealed|abstract|final|lazy|override)\b
      scope: storage.modifier.other.scala

    # language constants
    - match: \b(true|false|null)\b
      scope: constant.language.scala
    # characters
    - match: "'\\\\'"
      scope: invalid.illegal.lone-escape.scala
    - match: "'{{escaped_char}}'"
      scope: constant.character.escape.scala
    - match: "'.'"
      scope: constant.character.scala
    - match: "'[^']+'"
      scope: invalid.illegal.not_a_char.scala

    # numbers
    - match: '{{number}}'
      scope: constant.numeric.scala

    # import
    - match: \bimport\b
      scope: keyword.other.import
      push: import

    # string detection
    - match: '"""'
      scope: punctuation.definition.string.quoted.triple.begin.scala
      push: triple_string
    - match: 's"'
      scope: punctuation.definition.string.interpolated.begin.scala
      push: s_string
    - match: 'f"'
      scope: punctuation.definition.string.interpolated.begin.scala
      push: f_string
    - match: 'raw"'
      scope: punctuation.definition.string.quoted.raw.begin.scala
      push: raw_string
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.scala
      push: string

    # function calls
    - match: \b(Array|List|Map|Some)(\()
      captures:
        1: support.class entity.name.constructor.scala meta.invocation
        2: punctuation.definition.arguments.constructor.begin.scala
      push: function_args
    - match: \b(assert|assume|classOf|identity|implicitly|locally|manifest|optManifest|print|printf|println|require)(\()
      captures:
        1: support.function.scala meta.invocation
        2: punctuation.definition.arguments.begin.scala
      push: function_args

    - match: \b(new)\s{{name}}
      captures:
        1: keyword.operator.new.scala
        # 2: entity.name.type.new.scala
        2: variable.other.type.scala meta.instantiation.scala
      push: [constructor_block, constructor_mixin, constructor_arguments, constructor_type_arguments]

    - match: '([A-Z]{{name}})(\()'
      captures:
        1: entity.name.constructor.scala meta.invocation
        3: punctuation.definition.arguments.begin.scala
      push: function_args
    - match: '{{name}}(\()'
      captures:
        1: variable.function meta.invocation
        2: punctuation.definition.arguments.begin.scala
      push: function_args
    - match: '(?<=[)\]])(\()'
      captures:
        1: punctuation.definition.arguments.begin.scala
      push: function_args
    - match: '(?<=\w)(\()'
      captures:
        1: punctuation.definition.arguments.begin.scala
      push: function_args

    # tuples
    - match: '\)'
      scope: invalid.illegal.unexpected.closing-par
    - match: '(\()'
      captures:
        1: punctuation.definition.array.begin.scala
      push:
        - meta_scope: meta.tuple
        - match: ','
          scope: punctuation.separator.array-element.scala
        - match: '\)'
          scope: punctuation.definition.array.end.scala
          pop: true
        - include: main

    # builtin and operators
    - match: '(=)\s'
      captures:
        1: keyword.operator.assignment
    - match: '{{reserved_op}}'
      scope: support.function.scala
    - match: ';'
      scope: punctuation.terminator.statement.scala
    - match: ','
      scope: invalid.illegal.unexpected.coma
    - match: '\.'
      scope: keyword.operator.accessor.scala
    - match: \b(Array|List|Map|Some|None|Nil)\b
      scope: support.class.scala
    - match: \b(assert|assume|classOf|identity|implicitly|locally|manifest|optManifest|print|printf|println|require)\b
      scope: support.function.scala
    - match: '{{operator}}'
      scope: keyword.operator.scala

    # type parameters
    - include: type_bracket

    # try to match class name
    - match: '[A-Z]{{name}}?'
      scope: variable.other.type.scala
    - match: '{{name}}'
      scope: variable.other.scala
    # - include: punctuation

  # type
  type:
    # tuple of type
    - match: '\('
      scope: punctuation.definition.array.begin.scala
      push:
        - match: '\)'
          scope: punctuation.definition.array.end.scala
          pop: true
        - match: $
          pop: false
        - match: ','
          scope: punctuation.separator.array-element.scala
        - include: type
    - match: '\b(with)\b'
      scope: keyword.declaration.scala
    # type parameter
    - include: type_bracket
    - match: '(<:|<%)'
      scope: keyword.operator.type-bound.scala
    - match: '=>'
      scope: support.function.func-type.scala
    - match: \)
      scope: invalid.illegal.unexpected.closing-par
    - match: '{{operator}}'
      scope: keyword.operator.type.scala
    - match: '(List|Array|Map|Int|Float|Double|String|Char|Boolean)'
      scope: support.language.type.scala
    - match: '({{name}}(\.))*(type)'
      captures:
        2: variable.other.scala
        3: keyword.operator.access.scala
        4: support.language.type.scala
    - match: '({{name}}(\.))*{{name}}'
      captures:
        2: variable.other.scala
        3: keyword.operator.access.scala
        4: variable.other.type.scala
    - match: '{{name}}'
      scope: variable.other.type.scala
    - match: '(?=,|=)'
      pop: true
    - match: '$'
      pop: true
    # - include: punctuation

  type_bracket:
    - match: '\['
      scope: punctuation.definition.arguments.type.begin.scala
      push:
        - meta_scope: meta.arguments.type
        - match: '\]'
          scope: punctuation.definition.arguments.type.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.argument.type.scala
        - match: $
          pop: false
        - include: type
    - match: \]
      scope: invalid.illegal.stray-bracket-end

  import:
    - meta_scope: meta.import.scala
    - match: _
      scope: constant.language.scala
      pop: true
    - match: '{{name}}'
      scope: variable.module.scala
    - match: \.
      scope: keyword.operator.access.scala
    - match: $
      pop: true
    - match: \{
      scope: punctuation.definition.module-binding.begin.scala
      push:
        - match: \}
          scope: punctuation.definition.module-binding.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.module-binding
        - match: '{{name}}\s*(=>)\s*(_)'
          captures:
            1: meta.import.suppressed.scala
            2: support.function.mapping.scala
            3: constant.language.underscore.scala
        - match: '(=>)\s*({{name}})'
          captures:
            1: support.function.mapping.scala
            2: entity.name.class.imported
        - match: '([A-Z]{{name}}?)\s*(?=[,}])'
          captures:
            1: entity.name.class.imported

        # - include: import
    # - include: punctuation

  string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.scala
    - include: escaped
    - match: '"'
      scope: punctuation.definition.string.quoted.double.end.scala
      pop: true
    - match: '[^"]*$'
      scope: invalid.string.newline
      pop: true


  raw_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.scala
    - match: '"'
      scope: punctuation.definition.string.quoted.raw.end.scala
      pop: true
    - match: "[^\"]*$"
      scope: invalid.string.newline
      pop: true
    - match: \\u[0-9a-fA-F]{4}
      scope: constant.character.escape.scala

  triple_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.triple.scala
    - include: escaped
    - match: '"""'
      scope: punctuation.definition.string.quoted.triple.end.scala
      pop: true

  s_string:
    - meta_include_prototype: false
    - meta_scope: string.interpolated.scala
    - match: '(\$)\{'
      scope: punctuation.definition.string.interpolated.element.begin.scala
      push:
        - meta_scope: source.scala
        - match: '\}'
          scope: punctuation.definition.string.interpolated.element.end.scala
          pop: true
        - include: 'main'
    - match: '(\$){{name}}'
      captures:
        1: punctuation.definition.string.interpolated.element.scala
        2: source.scala variable.other.scala
    - match: '"'
      scope: punctuation.definition.string.interpolated.end.scala
      pop: true
    - include: escaped

  # f_string, see:
  # http://docs.oracle.com/javase/6/docs/api/java/util/Formatter.html#detail
  # /!\ this implementation may allow incorrect combinaisons
  f_string:
    - meta_include_prototype: false
    - meta_scope: string.interpolated.scala
    - include: s_string
    # constant formatting
    - match: '%[%n]'
      scope: punctuation.definition.string.interpolated.element.scala
    # general formatting
    - match: '%\-?#?[bBhHsS]'
      scope: punctuation.definition.string.interpolated.element.scala
    # character formatting
    - match: '%\-?[cC]'
      scope: punctuation.definition.string.interpolated.element.scala
    # date-time formatting
    - match: '%\-?[tT][HIklMSLNpzZsQBbhAaCYyjmdeRTrDFc]?'
      scope: punctuation.definition.string.interpolated.element.scala
    # floating point formatting
    - match: '%[\+\-# 0\(,]*[\.0-9]*[feEgGaA]'
      scope: punctuation.definition.string.interpolated.element.scala
    # integer formatting
    - match: '%[\+\-# 0\(,]*[doxX]'
      scope: punctuation.definition.string.interpolated.element.scala

  escaped:
    - match: '{{escaped_char}}'
      scope: constant.character.escape.scala
    - match: \\[0-7]{1,3}
      scope: constant.character.escape.scala
    - match: \\
      scope: invalid.illegal.lone-escape.scala

  # method signature
  signature:
    - meta_content_scope: meta.method.identifier.scala
    - match: '\('
      push: params
      scope: punctuation.definition.parameters.function.begin.scala
    - match: '\['
      scope: punctuation.definition.parameters.function.type.begin.scala
      push: type_params
    - match: ':'
      scope: punctuation.separator.key-value.type.scala
      set:
        - meta_content_scope: meta.method.identifier.scala
        - match: '(?==\s|\{)'
          pop: true
        - include: 'type'
    - match: '(?==\s|\{)'
      pop: true
    - match: $
      pop: true

  signature_end:
    - match: =\s
      scope: punctuation.definition.function.body.scala
      set: function_code
    - match: '(?=\{)'
      set: function_code
    - match: '(?=\S)'
      pop: true
    # abstract method, no code
    - match: $
      pop: true

  type_params:
    # - meta_scope: meta.method.identifier
    - match: '\]'
      scope: punctuation.definition.parameters.function.type.end.scala
      pop: true
    - match: '[$,]'
      pop: false
    - include: type

  params:
    # - meta_scope: params.scala
    - match: '\b(implicit)\b'
      scope: storage.modifier.other.implicit.scala
    - match: '{{name}}'
      captures:
        1: variable.parameter
      set:
        - match: '\s*(:)\s*'
          scope: punctuation.separator.key-value.type.scala
          set:
          - match: '\)'
            scope: punctuation.definition.parameters.function.end.scala
            pop: true
          - match: '=\s'
            scope: punctuation.separator.key-value.scala
            set:
              - match: '\)'
                scope: punctuation.definition.parameters.function.end.scala
                pop: true
              - match: ','
                scope: punctuation.separator.parameter.function.scala
                set: params
              - include: main
          - match: ','
            scope: punctuation.separator.parameter.function.scala
            set: params
          - match: '$'
            pop: false
          - include: type
        - match: '.*\)'
          scope: invalid.illegal.expected_col
          pop: true
    - match: '\)'
      scope: punctuation.definition.parameters.function.end.scala
      pop: true
    - match: '($|,)'
      pop: false

  function_code:
    - meta_scope: meta.def.scala
    - match: $
    - match: '^(\s*)(?=[^{])'
      set:
        - meta_scope: meta.def.scala
        - include: main
        - match: $
          pop: true
    - match: '(?=[^{])'
      set:
        - meta_scope: meta.def.scala
        - include: main
        - match: $
          pop: true
    - match: \s*
    - match: '\{'
      scope: punctuation.definition.function.body.begin.scala
      push:
        - match: '\}'
          scope: punctuation.definition.function.body.end.scala
          pop: true
        - include: main

  # class signature
  class_signature:
    - meta_scope: meta.class.scala
    - match: '\('
      scope: punctuation.definition.parameters.constructor.begin.scala
      push: class_params
    - match: '\['
      scope: punctuation.definition.parameters.constructor.type.begin.scala
      push:
        - meta_scope: meta.class.identifier.scala
        - match: '\]'
          scope: punctuation.definition.parameters.constructor.type.end.scala
          pop: true
        - match: $
        - match: ','
          scope: punctuation.separator.parameter.class.type
        - include: type

    - match: '\s*\b(extends|with)\s{{name}}'
      captures:
        1: storage.modifier.extends.scala
        2: entity.other.inherited-class.scala
      push: extends
    - match: '\{'
      scope: punctuation.definition.class.body.begin.scala
      push:
        - match: '\}'
          scope: punctuation.definition.class.body.end.scala
          pop: true
        - include: main
    - match: (?=\S)
      pop: true

  class_params:
    # - meta_content_scope: meta.constructor.scala
    - meta_scope: meta.class.identifier
    - match: '\b(val|protected|private)\b'
      scope: storage.modifier.access.scala
    - match: '\b(implicit)\b'
      scope: storage.modifier.other.implicit.scala
    - match: '{{name}}\s*(:)\s*'
      captures:
        1: variable.parameter.class.scala
        2: punctuation.separator.key-value.type.scala
      push:
        - match: (?=\)|,)
          pop: true
        - match: '=\s'
          scope: punctuation.separator.key-value.default.scala
          set:
            - match: (?=\)|,)
              pop: true
            - include: main
        - match: '$'
          pop: false
        - include: type
    - match: '\)'
      scope: punctuation.definition.parameters.constructor.end.scala
      pop: true
    - match: '($|,)'
      pop: false

  extends:
    # - meta_scope: meta.extends.scala
    - match: '\s*\b(with)\s{{name}}'
      captures:
        1: storage.modifier.extends.scala
        2: entity.other.inherited-class.scala
    - match: '\('
      scope: punctuation.definition.parameters.constructor.begin.scala
      push:
        - meta_content_scope: source.scala
        - match: '\)'
          scope: punctuation.definition.parameters.constructor.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.argument.scala
        - include: main
    - match: '(?=\{)'
      pop: true
    - match: '$'
    - include: type

  function_args:
    # - meta_content_scope: meta.class_args
    - match: ','
      scope: punctuation.separator.argument.scala
    - match: \)
      scope: punctuation.definition.arguments.end.scala
      pop: true
    - include: main

  pattern:
    - match: '\s*{{name}}?\s*(\()'
      captures:
        1: entity.name.constructor.unapply
        2: punctuation.definition.array.begin.scala
      set: [pattern_ended, pattern_inside_unapply]
    - match: '(?=\S)'
      set: [pattern_ended, pattern_typed_name]

  pattern_typed_name:
    - match: '(_)\s*(:)\s'
      captures:
        1: keyword.wildcard.pattern-matching.scala
        2: punctuation.separator.key-value.type.scala
      set:
        - match: '(?=\)|,|=\s|=>\s|<-\s)'
          pop: true
        - include: type
    - match: '(_)\s*(?=\)|,|=\s|=>\s|<-\s)'
      captures:
        1: keyword.wildcard.pattern-matching.scala
      pop: true
    - match: '{{name}}\s*(:)\s'
      captures:
        1: entity.name.val.scala
        2: punctuation.separator.key-value.type.scala
      set:
        - match: '(?=\)|,|=)'
          pop: true
        - include: type
    - match: '{{name}}\s*(?==\s|\)|,|=>\s)'
      captures:
        1: entity.name.val.scala
      pop: true
    - match: '{{name}}\s+{{name}}\s+'
      captures:
        1: entity.name.val.scala
        2: keyword.operator.infix-pattern
    - match: '\S+'
      scope: invalid.illegal.expected.pattern

  pattern_ended:
    - match: =>\s
      scope: punctuation.separator.key-value.switch.scala
      pop: true
    - match: =\s
      scope: keyword.operator.assignment
      pop: true
    - match: \s+
    - match: '{{name}}\s+(\()'
      captures:
        1: keyword.operator.infix-pattern
        2: punctuation.definition.array.begin.scala
      push: pattern_inside_unapply
    - match: '{{name}}\s+'
      scope: keyword.operator.infix-pattern
      push: pattern_typed_name
    - match: (\S*)
      scope: invalid.illegal.expected.assignment
      pop: true

  pattern_inside_unapply:
    # - meta_scope: inside_unnaply
    - match: '(?==)'
    - match: '=\s'
      scope: invalid.illegal.unexpected-eq
    - match: ','
      scope: punctuation.separator.array-element
    - match: '\)'
      scope: punctuation.definition.array.end.scala
      pop: true
    - match: '{{name}}?\s*(\()'
      captures:
        1: variable.other.type.unapply
        2: punctuation.definition.array.begin.scala
      push: pattern_inside_unapply
    - match: '(?=\S)'
      push: pattern_typed_name

  try_block:
    - meta_scope: meta.trycatch.try.scala
    - match: \{
      scope: punctuation.definition.block.trycatch.begin.scala
      set:
        - meta_scope: meta.trycatch.try.scala
        - match: \}
          scope: punctuation.definition.block.trycatch.end.scala
          pop: true
        - include: main
    - match: (?=\S)
      set:
        - match: \s*$
          pop: true
        - include: main

  catch_block:
    - match: (catch)\b
      scope: keyword.control.trycatch.catch.scala
      set:
        - match: \s*\{
          scope: punctuation.definition.block.trycatch.begin.scala
          set:
            - meta_scope: meta.trycatch.catch.scala
            - match: \}
              scope: punctuation.definition.block.trycatch.end.scala
              pop: true
            - match: \b(case)\b
              scope: keyword.control.trycatch.case.scala
              push: pattern
            - include: main
        - match: \}
          scope: punctuation.definition.block.trycatch.end.scala
          pop: true
        - match: (\s*)(?=\S)
          scope: invalid.illegal.expected_block
          pop: true
    - match: (?=\S)
      pop: true

  finally_block:
    - match: (finally)\b
      scope: keyword.control.trycatch.finally.scala
      set:
        - match: \s*
        - match: \{
          scope: punctuation.definition.block.trycatch.begin.scala
          set:
            - meta_scope: meta.trycatch.finally.scala
            - match: \}
              scope: punctuation.definition.block.trycatch.end.scala
              pop: true
            - include: main
        - match: (?=\S)
          set:
            - meta_scope: meta.trycatch.finally.scala
            - include: line_of_code
    - match: (?=\S)
      pop: true

  if_condition:
    - match: '\('
      scope: punctuation.definition.expression.conditional.end.scala
      set:
        - meta_scope: meta.if.condition
        - match: '\)'
          scope: punctuation.definition.expression.conditional.end.scala
          pop: true
        - include: main
    - match: (\s*)(?=\S)
      scope: invalid.illegal.expected.condition
      pop: true

  if_block:
    # - meta_scope: meta.block.conditional.scala
    - include: scaladoc_open
    - match: \{
      scope: punctuation.definition.block.conditional.begin.scala
      set:
        - meta_scope: meta.block.conditional.scala
        - match: \}
          scope: punctuation.definition.block.conditional.end.scala
          pop: true
        - include: main
    - match: (?=\S)
      set:
        - match: (?=else\b)
          pop: true
        - include: line_of_code

  else_block:
    - meta_scope: meta.block.conditional.scala
    - include: scaladoc_open
    - match: (else\s+if)\s*
      captures:
        1: keyword.control.conditional.elseif.scala
      push: [if_block, if_condition]
    - match: (else)\b
      scope: keyword.control.conditional.else.scala
      set:
        - match: \s*\{
          scope: punctuation.definition.block.conditional.begin.scala
          set:
            - meta_scope: meta.block.conditional.scala
            - match: \}
              scope: punctuation.definition.block.conditional.end.scala
              pop: true
            - include: main
        - match: (?=\S)
          set:
            - meta_scope: meta.block.conditional.scala
            - include: line_of_code
    - match: (?=\S)
      pop: true

  constructor_type_arguments:
    - match: '\['
      scope: punctuation.definition.arguments.type.begin.scala
      set:
        - meta_scope: meta.arguments.type
        - match: '\]'
          scope: punctuation.definition.arguments.type.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.argument.type.scala
        - match: $
          pop: false
        - include: type
    - match: '(?=\S|$)'
      pop: true

  constructor_arguments:
    - meta_scope: constructor_arguments
    - match: \(
      scope: punctuation.definition.arguments.begin.scala
      push:
        - match: \)
          scope: punctuation.definition.arguments.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.argument.scala
        - include: main
    - match: (?=\S|$)
      pop: true

  constructor_mixin:
    - meta_scope: constructor_mixin
    - match: \b(with)\b
      scope: keyword.operator.new.with.scala
      push:
        - match: (?=\bwith\b)
          pop: true
        - match: (?=\{|$)
          pop: true
        - match: '{{name}}'
          scope: variable.other.type.scala meta.instantiation.scala
          set: constructor_type_arguments
    - match: (?=\S|$)
      pop: true

  constructor_block:
    - match: \{
      scope: punctuation.definition.class.body.begin.scala
      set:
        - meta_scope: meta.class.anonymous.scala
        - match: \}
          scope: punctuation.definition.class.body.end.scala
          pop: true
        - include: main
    - match: (?=\S|$)
      pop: true

  line_of_code:
    - match: $
      pop: true
    - include: main

  xml:
    - meta_scope: text.xml
    - match: '({{xml_open_tag}})([^{]*)({{xml_close_tag}})'
      captures:
        1: entity.name.tag
        2: string.unquoted.xml
        3: entity.name.tag
    - match: '\{'
      captures:
        1: entity.name.tag
      push:
        - meta_scope: source.scala
        - match: '\}'
          pop: true
        - include: main
    - match: '{{xml_open_tag}}'
      scope: entity.name.tag
      push: xml
    - match: '{{xml_close_tag}}'
      scope: entity.name.tag
      pop: true

  scaladoc:
    - meta_include_prototype: false
    - meta_scope: comment.block.documentation.scala
    - match: '@(author|version|since)\b'
      scope: keyword.documentation.inventory.scala
    - match: '@(note|example|usecase)\b'
      scope: keyword.documentation.usage.scala
    - match: '@(todo)\b'
      scope: keyword.documentation.other.scala comment.todo.scala
    - match: '@(return|constructor)\b'
      scope: keyword.documentation.parameter.scala
    - match: '(@param)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: variable.parameter
    - match: '(@tparam)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: variable.other.type.scala
    - match: '(@throws)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: entity.name.class.scala
    - match: '(@see)\s+{{name}}'
      captures:
        1: keyword.documentation.link.scala
        2: entity.name.module.scala
    - match: '(\$){{name}}'
      captures:
        1: punctuation.definition.string.interpolated.element.scala
        2: entity.name.macro.scala
    - match: '(@define)\s+{{name}}\s'
      captures:
        1: keyword.documentation.other.scala
        2: entity.name.macro.scala
    - match: '@(inheritdoc)\b'
      scope: keyword.documentation.other.scala

    - include: scaladoc-markup

  scaladoc-markup:
    - match: '\s*\*/'
      pop: true
    - match: '^\s*\*'
      scope: comment.block.documentation.scala
    - match: '^(\s*.).*$'
      captures:
        1: invalid.illegal.missing-asterisk
    - match: "'''"
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope: markup.bold
        - match: "'''"
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: "''"
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope: markup.italic
        - match: "''"
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '__'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope: markup.underline
        - match: '__'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '\^'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope: markup.superscipt
        - match: '\^'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: ',,'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope: markup.subscipt
        - match: ',,'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '`'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope: markup.monospace
        - match: '`'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '\{\{\{'
      scope: constant.character.escaped.scaladoc
      set:
        - match: '\}\}\}'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
        - match: .
          scope : markup.code



