%YAML 1.2
---
name: Scala
file_extensions: [.scala, .sbt]
scope: 'source.scala'


variables:

  # _ : = => <- <: <% >: # @
  reserved_op: '(_|:|=>|=|<-|<:|<%|>:|#)'

  # see this SO question for more details:
  # http://stackoverflow.com/questions/7656937/valid-identifier-characters-in-scala
  operator: '[!#%&\*\+\-/:<=>?\\^|~©®][!#%&\*\+\-/:<=>?@\\^|~©®]*'
  simple_name: '[A-Za-z_\p{L}][A-Za-z\p{L}_0-9]*'
  name_with_op: '({{operator}}|{{simple_name}}_{{operator}})'
  name: '({{operator}}|{{simple_name}}_{{operator}}|{{simple_name}})'
  full_name: '({{operator}}\s|{{simple_name}}_{{operator}}\s|{{simple_name}}\s?)'

  tagname: '@{{name}}'

  xml_open_tag: '<[A-Za-z]*>'
  xml_close_tag: "</[A-Za-z]*>"

  # integers
  hex_numeral: '0[xX][0-9a-fA-F]+'
  decimal_numeral: '[1-9][0-9]*[lL]'
  integers: '({{hex_numeral}}|{{decimal_numeral}}|0)'

  # floating point numbers
  exponent: '[eE][+\-]?[0-9]+'
  floating_point: '[0-9]+(?:\.[0-9]+)?(?:{{exponent}})?[fFdD]?'
  number: '({{hex_numeral}}|{{decimal_numeral}}|{{floating_point}}|0)'
  # characters
  escaped_char: \\([btnfr"'\\]|u[0-9a-fA-F]{4})
  char: '(?:{{escaped_char}}|.)'
  string: '(f|s|raw)?\"[^\"]*\"'
  literal: '({{number}}|{{char}}|{{string}})'
  variable: '({{name}}\.)*{{name}}'
  value: '({{literal}}|{{variable}})'

contexts:
  prototype:
    - include: 'comments'

  # comments
  comments:
    - match: '//.*$'
      scope: comment.line.double-slash.scala
    - match: '/\*[^*]'
      push:
        - meta_scope: comment.block.scala
        - match: '\*/'
          pop: true

  # punctuation:
  #   - match: (\.|\,)
  #     scope: keyword.operator.scala

  main:
    #TODO: forSome

    # scaladoc is triggered only on new line
    - match: '^\s*/\*\*'
      push: scaladoc

    # skips opening
    - match: ^\s*

    # annotations
    - match: '{{tagname}}'
      scope: entity.name.tag

    # embedded xml see:
    # http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#xml-mode
    - match: '[\s({]{{xml_open_tag}}'
      scope: entity.name.tag
      push: xml
    - match: '{{xml_close_tag}}'
      scope: invalid.illegal.xml-close-tag


    # packages/object declaration
    - match: '\b(package)\s(({{simple_name}}\.)*{{simple_name}})'
      captures:
        1: keyword.other.scoping.scala
        2: entity.name.package.scala

    # class declaration
    - match: '\b(case\s)?(trait|class|object)\s{{name}}'
      captures:
        1: keyword.declaration.scala
        2: keyword.declaration.scala
        3: entity.name.class.scala
      push: class_signature

    # function/method definition
    - match: '(def)\s({{name}})'
      captures:
         1: keyword.declaration.scala
         2: entity.name.function.scala
      push: signature

    # val/var declaration
    - match: '\b(val|var)\s{{name}}'
      captures:
        1: keyword.declaration.scala
        2: entity.name.val.scala
      push: optional_type

    # type declaration
    - match: '\b(type)\s+{{name}}\s*(=|<:|<%)'
      captures:
        1: keyword.declaration.scala
        2: entity.name.type.scala
        3: keyword.eq.scala
      push: type

    # language keywords
    - match: \b(if|else|for|while|do|match|case|return|yield)\b
      scope: keyword.control.flow.scala
    - match: \b(try|catch|finally)\b
      scope: keyword.control.exception.scala
    - match: \b(throw)\b
      scope: keyword.control.jump.scala
    - match: \b(this|super)\b
      scope: variable.language.scala
    - match: \b(new)\s{{name}}
      captures:
        1: keyword.declaration.new.scala
        2: variable.other.type.scala
    - match: \b(sealed|abstract|final|lazy|override)\b
      scope: storage.modifier.other.scala

    # private/protected with modifier
    - match: '\b(private|protected)\s*\[(this)\]'
      captures:
        1: storage.modifier.other.scala
        2: variable.language.scala
    - match: '\b(private|protected)\s*(\[){{name}}(\])'
      captures:
        1: storage.modifier.other.scala
        2: punctuation.declaration.parameters.begin.scala
        3: punctuation.declaration.parameters.end.scala
    - match: \b(private|protected)\b
      scope: storage.modifier.access.scala

    # language constants
    - match: \b(true|false|None|Nil|null)\b
      scope: constant.language.scala
    # characters
    - match: "'\\\\'"
      scope: invalid.illegal.lone-escape.scala
    - match: "'{{escaped_char}}'"
      scope: constant.character.escape.scala
    - match: "'.'"
      scope: constant.character.scala
    - match: "'[^']+'"
      scope: invalid.illegal.not_a_char.scala

    # numbers
    - match: '{{number}}'
      scope: constant.numeric.scala

    # import
    - match: \bimport\b
      scope: keyword.other.import
      push: import

    # extends and with can be found on a newline
    - match: '(extends|with)\s{{name}}'
      captures:
        1: keyword.declaration.scala
        2: entity.other.inherited-class.scala
      set: extends

    # string detection
    - match: '"""'
      scope: punctuation.definition.string.quoted.triple.begin.scala
      push: triple_string
    - match: 's"'
      scope: punctuation.definition.string.interpolated.begin.scala
      push: s_string
    - match: 'f"'
      scope: punctuation.definition.string.interpolated.begin.scala
      push: f_string
    - match: 'raw"'
      scope: punctuation.definition.string.quoted.raw.begin.scala
      push: raw_string
    - match: '"'
      scope: punctuation.definition.string.quoted.double.begin.scala
      push: string

    # builtin and operators
    - match: '{{reserved_op}}'
      scope: support.function.builtin.scala
    - match: ';'
      scope: punctuation.separator.semi-colon.scala
    - match: ','
      scope: punctuation.separator.coma.scala
    - match: '\.'
      scope: punctuation.separator.dot.scala
    - match: \b(Array|List|Map|Some)\b
      scope: support.class.builtin.scala
    - match: \b(assert|assume|classOf|identity|implicitly|locally|manifest|optManifest|print|printf|println|require)\b
      scope: support.function.builtin.scala
    - match: '{{operator}}'
      scope: keyword.operator.scala

    # type parameters
    - match: \[
      push:
        - match: \]
          pop: true
        - include: type
    - match: \]
      scope: invalid.illegal.stray-bracket-end

    # try to match class name
    - match: '[A-Z]{{name}}?'
      scope: variable.other.type
    - match: '{{name}}'
      # scope: variable.other
    # - include: punctuation

  # type
  type:
    # tuple of type
    - match: '\('
      scope: punctuation.definition.parameters.begin.scala
      push:
        - match: '\)'
          scope: punctuation.definition.parameters.end.scala
          pop: true
        - match: '[$,]'
          pop: false
        - include: type
    - match: '\b(with)\b'
      scope: keyword.declaration.scala
    # type parameter
    - match: '\['
      scope: punctuation.definition.parameters.begin.scala
      push:
        - match: '\]'
          scope: punctuation.definition.parameters.end.scala
          pop: true
        - match: '[$,]'
          pop: false
        - include: type
    - match: '(<:|<%)'
      scope: keyword.operator.type-bound.scala
    - match: '=>'
      scope: support.function.func-type.scala
    - match: \]|\)
      scope: invalid.illegal.stray-bracket-end
    - match: '{{name}}'
      scope: variable.other.type
    - match: '='
      scope: keyword.eq.scala
      pop: true
    - match: '(,|$)'
      pop: true
    # - include: punctuation


  import:
    - meta_scope: meta.import.scala
    - match: _
      scope: constant.language.scala
      pop: true
    - match: '{{name}}'
      scope: variable.package.scala
    - match: \.
      scope: punctuation.separator.dot
    - match: $
      pop: true
    - match: \{
      scope: punctuation.definition.module-binding.begin.scala
      push:
        - match: \}
          scope: punctuation.definition.module-binding.end.scala
          pop: true
        - match: ','
          scope: punctuation.separator.coma
        - match: '{{name}}\s*(=>)\s*(_)'
          captures:
            1: meta.import.suppressed.scala
            2: support.function.mapping.scala
            3: constant.language.underscore.scala
        - match: '(=>)\s*({{name}})'
          captures:
            1: support.function.mapping.scala
            2: entity.name.class
        - match: '([A-Z]{{name}}?)\s*(?=[,}])'
          captures:
            1: entity.name.class.imported

        # - include: import
    # - include: punctuation

  string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.scala
    - include: escaped
    - match: '"'
      scope: punctuation.definition.string.quoted.double.end.scala
      pop: true
    - match: '[^"]*$'
      scope: invalid.string.newline
      pop: true


  raw_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.scala
    - match: '"'
      scope: punctuation.definition.string.quoted.raw.end.scala
      pop: true
    - match: "[^\"]*$"
      scope: invalid.string.newline
      pop: true
    - match: \\u[0-9a-fA-F]{4}
      scope: constant.character.escape.scala

  triple_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.triple.scala
    - include: escaped
    - match: '"""'
      scope: punctuation.definition.string.quoted.triple.end.scala
      pop: true

  s_string:
    - meta_include_prototype: false
    - meta_scope: string.interpolated.scala
    - match: '(\$)\{'
      scope: punctuation.definition.string.interpolated.element.begin.scala
      push:
        - meta_scope: source.scala
        - match: '\}'
          scope: punctuation.definition.string.interpolated.element.end.scala
          pop: true
        - include: 'main'
    - match: '(\$){{name}}'
      captures:
        1: punctuation.definition.string.interpolated.element.scala
        2: source.scala
    - match: '"'
      scope: punctuation.definition.string.interpolated.end.scala
      pop: true
    - include: escaped

  # f_string, see:
  # http://docs.oracle.com/javase/6/docs/api/java/util/Formatter.html#detail
  # /!\ this implementation may allow incorrect combinaisons
  f_string:
    - meta_include_prototype: false
    - meta_scope: string.interpolated.scala
    - include: s_string
    # constant formatting
    - match: '%[%n]'
      scope: punctuation.definition.string.interpolated.element.scala
    # general formatting
    - match: '%\-?#?[bBhHsS]'
      scope: punctuation.definition.string.interpolated.element.scala
    # character formatting
    - match: '%\-?[cC]'
      scope: punctuation.definition.string.interpolated.element.scala
    # date-time formatting
    - match: '%\-?[tT][HIklMSLNpzZsQBbhAaCYyjmdeRTrDFc]?'
      scope: punctuation.definition.string.interpolated.element.scala
    # floating point formatting
    - match: '%[\+\-# 0\(,]*[\.0-9]*[feEgGaA]'
      scope: punctuation.definition.string.interpolated.element.scala
    # integer formatting
    - match: '%[\+\-# 0\(,]*[doxX]'
      scope: punctuation.definition.string.interpolated.element.scala

  escaped:
    - match: '{{escaped_char}}'
      scope: constant.character.escape.scala
    - match: \\[0-7]{1,3}
      scope: constant.character.escape.scala
    - match: \\
      scope: invalid.illegal.lone-escape.scala

  # method signature
  signature:
    # - meta_scope: 'signature.scala'
    - match: '\('
      push: 'params'
      scope: punctuation.definition.parameters.begin.scala
    - match: '\['
      scope: punctuation.definition.parameters.begin.scala
      push: 'type_params'
    - include: 'optional_type'

  type_params:
    # - meta_scope: 'type_params.scala'
    - match: '\]'
      scope: punctuation.definition.parameters.end.scala
      pop: true
    - match: '[$,]'
      pop: false
    - include: 'type'

  params:
    - meta_scope: 'params.scala'
    - match: '\b(implicit)\b'
      scope: 'storage.modifier.other'
    - match: '{{name}}'
      captures:
        1: variable.parameter
      set:
        - match: '\s*(:)\s*'
          scope: punctuation.separator.colon.scala
          set:
          - match: '\)'
            scope: punctuation.definition.parameters.end.scala
            pop: true
          - match: '=\s'
            scope: keyword.eq.scala
            set:
              - match: '\)'
                scope: punctuation.definition.parameters.end.scala
                pop: true
              - match: ','
                set: params
              - include: main
          - match: ','
            scope: punctuation.separator.coma.scala
            set: params
          - match: '$'
            pop: false
          - include: type
        - match: (.*)
          scope: invalid.illegal.expected_col
    - match: '\)'
      scope: punctuation.definition.parameters.end.scala
      pop: true
    - match: '($|,)'
      pop: false

  optional_type:
    - match: ':'
      scope: punctuation.separator.colon.scala
      set:
        # - meta_scope: 'optional_type.scala'
        - match: '$'
          pop: false
        - match: '='
          scope: 'keyword.eq.scala'
          pop: true
        - match: '[){]'
          pop: true
        - include: 'type'
    - match: '='
      scope: 'keyword.eq.scala'
      pop: true
    - match: '(\{)'
      pop: true
    - match: '$'
      pop: true
    # - include: 'type'
    # - match: expr
    #   scope: variable.parameter
    # push:
    #   - match: ","
    #     pop: true

  # class signature
  class_signature:
    # - meta_scope: 'signature.scala'
    - match: '\('
      scope: punctuation.definition.parameters.begin.scala
      push: 'class_params'
    - match: '\['
      scope: punctuation.definition.parameters.begin.scala
      push: 'type_params'
    - match: '\b(extends|with)\s{{name}}'
      captures:
        1: keyword.declaration.scala
        2: entity.other.inherited-class.scala
      set: extends
    - include: 'optional_type'

  class_params:
    # - meta_scope: 'class_params.scala'
    - match: '\b(implicit|val|protected|private)\b'
      scope: 'storage.modifier.other'
    - match: '{{name}}'
      captures:
        1: variable.parameter
      set:
        - match: '\s*(:)\s*'
          scope: punctuation.separator.colon.scala
          set:
          - match: '\)'
            scope: punctuation.definition.parameters.end.scala
            pop: true
          - match: '=\s'
            scope: keyword.eq.scala
            set:
              - match: '\)'
                scope: punctuation.definition.parameters.end.scala
                pop: true
              - match: ','
                scope: punctuation.separator.coma.scala
                set: class_params
              - include: main
          - match: ','
            scope: punctuation.separator.coma.scala
            set: class_params
          - match: '$'
            pop: false
          - include: type
        - match: (.*)
          scope: invalid.illegal.expected_col
    - match: '\)'
      scope: punctuation.definition.parameters.end.scala
      pop: true
    - match: '($|,)'
      pop: false

  extends:
    # - meta_scope: extends
    - match: '\b(with)\s{{name}}'
      captures:
        1: keyword.declaration.scala
        2: entity.other.inherited-class.scala
    - match: '(?=\{)'
      pop: true
    - match: '\('
      scope: punctuation.definition.parameters.begin.scala
      push:
        - match: '\)'
          scope: punctuation.definition.parameters.end.scala
          pop: true
        - include: main
    - include: type

  xml:
    - meta_scope: text.xml
    - match: '({{xml_open_tag}})([^{]*)({{xml_close_tag}})'
      captures:
        1: entity.name.tag
        2: string.unquoted.xml
        3: entity.name.tag
    - match: '\{'
      captures:
        1: entity.name.tag
      push:
        - meta_scope: source.scala
        - match: '\}'
          pop: true
        - include: main
    - match: '{{xml_open_tag}}'
      scope: entity.name.tag
      push: xml
    - match: '{{xml_close_tag}}'
      scope: entity.name.tag
      pop: true

  scaladoc:
    - meta_include_prototype: false
    - meta_scope: comment.block.documentation.scala
    - match: '@(author|version|since)\b'
      scope: keyword.documentation.inventory.scala
    - match: '@(note|example|usecase)\b'
      scope: keyword.documentation.usage.scala
    - match: '@(todo)\b'
      scope: keyword.documentation.other.scala comment.todo.scala
    - match: '@(return|constructor)\b'
      scope: keyword.documentation.parameter.scala
    - match: '(@param)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: variable.parameter
    - match: '(@tparam)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: variable.other.type.scala
    - match: '(@throws)\s+{{name}}'
      captures:
        1: keyword.documentation.parameter.scala
        2: entity.name.type.scala
    - match: '(@see)\s+{{name}}'
      captures:
        1: keyword.documentation.link.scala
        2: entity.name.package.scala
    - match: '(\$){{name}}'
      captures:
        1: punctuation.definition.string.interpolated.element.scala
        2: entity.name.macro.scala
    - match: '(@define)\s+{{name}}\s'
      captures:
        1: keyword.documentation.other.scala
        2: entity.name.macro.scala
    - match: '@(inheritdoc)\b'
      scope: keyword.documentation.other.scala

    - include: scaladoc-markup

  scaladoc-markup:
    - match: '\s*\*/'
      pop: true
    - match: '^\s*\*'
      scope: comment.block.documentation.scala
    - match: '^(\s*.).*$'
      captures:
        1: invalid.illegal.missing-asterisk
    - match: "'''"
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.bold
        - match: "'''"
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: "''"
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.italic
        - match: "''"
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '__'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.underline
        - match: '__'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '\^'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.superscipt
        - match: '\^'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: ',,'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.subscipt
        - match: ',,'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '`'
      scope: constant.character.escaped.scaladoc
      set:
        - meta_content_scope : markup.monospace
        - match: '`'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
    - match: '\{\{\{'
      scope: constant.character.escaped.scaladoc
      set:
        - match: '\}\}\}'
          scope: constant.character.escaped.scaladoc
          set: scaladoc
        - include: scaladoc-markup
        - match: .
          scope : markup.code



